(let ~!$%^*_-+|\=<>/? 10) ; 这些都是合法标识符字符
; (let &@#. 100) ;不合法的标识符字符
(let foo {foo1: {foo2: {foo3: "real value"}}})
(let bar foo.foo1.foo2.foo3) ; bar为"real value", foo.foo1.foo2.foo3是multi-symbol
(let foo3 :foo3)
(let bar1 (. foo :foo1 :foo2 foo3)) ;bar1也是"real value"，.是解构运算符
(let bar2 (. foo))
(let b (= bar2 foo (. foo) .foo)) ; b为true
(let {foo: bar} mymap) ; bar是新绑定的标识符，foo是mymap中的key符号的名字
(let {foo, bar} mymap) ; foo, bar是两个新绑定的标识符，这是`{foo: foo, bar: bar}`的简写
(let [a b &c] mylist)  ; a/b/c是新绑定的标识符，c是mylist中除了开头两个元素之外的剩余元素的list
(let {a, b: b1, c} mymap) ; a/b1/c是新绑定的标识符，b是导入的原始名字，b1是b的重命名

(fn myfun []:
  (let a 1)
  (let b 2)
  (values a b 3 4))
(let a b c _ (myfun)) ; 由于不关注第四个参数，所以使用_代替，_开头的变量只是占位符。
(print a b c) ; 输出1 2 3
(fn myfun2 [a b c d]:
  (print a b c d))
(myfun2 (myfun)) ; myfun返回四个值，可以直接扩展为myfun2的四个参数

(let foo :foo)
(let bar :bar)
(values foo bar)
(let a b (values foo bar)) ; ok
(let ab (values foo bar))  ; error
